package cz.brmlab.yodaqa.flow.asb;

import java.util.HashMap;
import java.util.Map;

import org.apache.uima.Constants;
import org.apache.uima.UIMAFramework;
import org.apache.uima.analysis_engine.AnalysisEngine;
import org.apache.uima.analysis_engine.AnalysisEngineDescription;
import org.apache.uima.analysis_engine.TextAnalysisEngine;
import org.apache.uima.impl.AnalysisEngineFactory_impl;
import org.apache.uima.resource.Resource;
import org.apache.uima.resource.ResourceCreationSpecifier;
import org.apache.uima.resource.ResourceInitializationException;
import org.apache.uima.resource.ResourceSpecifier;

/** A variant of AnalysisEngineFactory that creates ParallelAnalysisEngine
 * instead of AggregateAnalysisEngine and to non-aggregate non-multiplier
 * engines automatically passes PARAM_NUM_SIMULTANEOUS_REQUESTS.
 * The ParallelAnalysisEngine works the same, but uses a modified Analysis
 * Structure Broker MultiThreadASB that uses a thread pool to spread logically
 * parallelizable work.  The extra parameter for non-aggregate engines creates
 * a transparent pool of actual instances so that each thread uses a different
 * instance.
 *
 * To disable multiprocessing engine pool for a particular engine (like CAS
 * mergers!), pass PARAM_NO_MULTIPROCESSING to it.
 *
 * Also, on seeing PARAM_NUM_SIMULTANEOUS_REQUESTS, instead of
 * MultiprocessingAnalysisEngine_impl a tweaked class that works properly
 * even with CAS multipliers is instantiated. */

public class ParallelEngineFactory extends AnalysisEngineFactory_impl {
	/** Disable automatic creation of pool of independent engines for
	 * the purpose of parallelization.  This means that instead
	 * of N times, the AnalysisEngine will be instantiated just
	 * once, and multiple threads may invoke it independently.
	 * Therefore, methods of this AE should be all synchronized
	 * or use proper locking!  You want to use this for CAS mergers
	 * (which want to collect all CASes from all threads in a single
	 * place), or for AEs that use thread-unsafe static members.
	 *
	 * N.B. This can actually be passed both as a configuration parameter
	 * (passed when creating a pipeline) and internally generated by
	 * ParallelEngineFactory as an engine additional parameter (internal
	 * for AE factory). */
	public static final String PARAM_NO_MULTIPROCESSING = "-no-multiprocessing";

	/** Register this class a new kind of AnalysisEngineFactory
	 * that overrides the default one and will chuck out
	 * ParallelAnalysisEngine instead of AggregateAnalysisEngine.
	 * It is very similar, but uses a modified Analysis Structure Broker
	 * MultiThreadASB that uses a thread pool to perform logically
	 * parallelizable work in parallel.
	 *
	 * N.B. This operation makes it more complicated to use
	 * nested UIMA pipelines!!!  See the LATNormalize class
	 * for some discussion and examples of dealing with this. */
	public static void registerFactory() {
		UIMAFramework.getResourceFactory().registerFactory(ResourceCreationSpecifier.class, new ParallelEngineFactory());
	}

	public Resource produceResource(Class<? extends Resource> aResourceClass, ResourceSpecifier aSpecifier,
			Map<String, Object> aAdditionalParams) throws ResourceInitializationException {
		/* Shortcut way out for non-AEs. */
		if (!(aSpecifier instanceof AnalysisEngineDescription))
			return super.produceResource(aResourceClass, aSpecifier, aAdditionalParams);
		AnalysisEngineDescription aEngineSpecifier = (AnalysisEngineDescription) aSpecifier;

		/* We auto-decorate some engines with
		 * PARAM_NUM_SIMULTANEOUS_REQUESTS,
		 * either generated by us or passed from the outside. */
		boolean noMultiprocessing = (aAdditionalParams != null && aAdditionalParams.containsKey(PARAM_NO_MULTIPROCESSING))
			|| (aEngineSpecifier.getAnalysisEngineMetaData().getConfigurationParameterSettings().getParameterValue(PARAM_NO_MULTIPROCESSING) != null);
		if (aEngineSpecifier.isPrimitive() && !noMultiprocessing) {
			/* Decorate with PARAM_NUM_SIMULTANEOUS_REQUESTS. */
			if (aAdditionalParams != null)
				aAdditionalParams = new HashMap<>(aAdditionalParams);
			else
				aAdditionalParams = new HashMap<>();
			aAdditionalParams.put(AnalysisEngine.PARAM_NUM_SIMULTANEOUS_REQUESTS, MultiThreadASB.maxJobs);
			/* We will come here again from within
			 * MultiprocessingAnalysisEngine_impl, so prevent
			 * recursion. */
			aAdditionalParams.put(PARAM_NO_MULTIPROCESSING, 1);
		} else if (!aEngineSpecifier.isPrimitive() && aAdditionalParams != null) {
			/* Undo our previous tag in order not to disable
			 * mp for component engines */
			aAdditionalParams = new HashMap<>(aAdditionalParams);
			aAdditionalParams.remove(PARAM_NO_MULTIPROCESSING);
		}

		/* Now, we just check whether this would produce
		 * an AggregateAnalysisEngine and instantiate
		 * a ParallelAnalysisEngine instad in that case;
		 * we repeat the super's checks as they are written there. */
		boolean multiprocessing = (aAdditionalParams != null)
			&& aAdditionalParams.containsKey(AnalysisEngine.PARAM_NUM_SIMULTANEOUS_REQUESTS);
		Resource resource = null;
		if (multiprocessing) {
			resource = new MultiprocessingAnalysisEngine_MultiplierOk();
		} else if (aResourceClass.isAssignableFrom(TextAnalysisEngine.class)) {
			ResourceCreationSpecifier spec = (ResourceCreationSpecifier) aSpecifier;
			String frameworkImpl = spec.getFrameworkImplementation();
			if (frameworkImpl != null
			    && frameworkImpl.startsWith(Constants.JAVA_FRAMEWORK_NAME)
			    && !aEngineSpecifier.isPrimitive()) {
				resource = new ParallelAnalysisEngine();
			}
		}

		if (resource != null) {
			if (resource.initialize(aSpecifier, aAdditionalParams))
				return resource;
			else
				return null;
		} else {
			return super.produceResource(aResourceClass, aSpecifier, aAdditionalParams);
		}
	}
}
